<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>出発時間の共有</title>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<style>
:root{
  --bg:#f7f7fb; --ink:#222; --muted:#6b7280;
  --brand:#ff7043; --accent:#2563eb;
  --grid:#e5e7eb; --hour:#d1d5db;
  --card-ink:#fff; --shadow:0 6px 18px rgba(0,0,0,.08);
  --radius:14px; --col-gap:10px;
  --px-per-min:3; /* 1分=3px（3h=540px） */
  /* メンバー固定色（列背景は薄く、カードは濃く） */
  --col0:#e6f0ff; --card0:#3b82f6; /* のすけ */
  --col1:#ffe7ee; --card1:#ef476f; /* ママ   */
  --col2:#e7fbf5; --card2:#06d6a0; /* そう   */
  --col3:#fff3df; --card3:#ffa600; /* しゅう */
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0;
  padding-top:calc(env(safe-area-inset-top) + 6px); /* ステータスバー回避 */
  font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Hiragino Sans","Noto Sans JP",Arial,sans-serif;
  background:var(--bg); color:var(--ink);
}
.app{ max-width:1100px; margin:0 auto; padding:8px 10px calc(env(safe-area-inset-bottom) + 16px); }

/* ヘッダー（コンパクト＋視認性UP） */
.header{
  display:flex; align-items:center; justify-content:space-between;
  gap:8px; margin-bottom:8px;
}
.title{
  background:#fff; border-radius:12px; box-shadow:var(--shadow);
  padding:6px 10px; line-height:1.2; min-height:44px;
  display:flex; align-items:center; gap:10px; flex-wrap:wrap;
}
.ttl{font-size:16px; font-weight:800}
.place{
  font-weight:800; color:#111; font-size:15px; min-width:180px;
}
.departBig{
  font-weight:900; color:var(--brand); font-size:18px; letter-spacing:0.03em;
}
.countdown{font-weight:800; color:#111; font-variant-numeric:tabular-nums;}
.controls{ display:flex; gap:8px; align-items:center; }
.btn{
  appearance:none; border:0; border-radius:10px; padding:8px 10px; font-weight:600; background:#fff;
  box-shadow:var(--shadow); color:var(--ink); font-size:14px;
}
.btn.primary{ background:var(--brand); color:#fff }
.btn.ghost{ background:transparent; border:1px solid var(--grid) }
.input{
  background:#fff; box-shadow:var(--shadow); border-radius:10px; padding:8px 10px; border:1px solid transparent; font-size:14px;
}

/* タイムライン（縦スクロール） */
.gridwrap{
  position:relative; z-index:1;
  background:#fff; border-radius:var(--radius); box-shadow:var(--shadow);
  padding:8px; overflow:auto; max-height:70vh; touch-action:pan-y;
}
.grid{
  display:grid;
  grid-template-columns:64px repeat(4,1fr);
  gap:var(--col-gap);
  height:540px; /* 3h * 60 * 3px（JSで再設定） */
  position:relative;
}
.timeAxis{position:relative}
.timeAxis .tick{position:absolute; left:0; right:0; height:1px; background:var(--grid)}
.timeAxis .hour{background:var(--hour); height:1.5px}
.timeAxis .label{ position:absolute; left:0; top:-9px; font-size:12px; color:var(--muted); }

/* メンバー列（縦帯カラー） */
.memberCol{
  position:relative; border-left:1px dashed var(--grid); border-right:1px dashed var(--grid);
  border-radius:8px; overflow:visible;
}
.memberCol[data-index="0"]{ background:var(--col0); }
.memberCol[data-index="1"]{ background:var(--col1); }
.memberCol[data-index="2"]{ background:var(--col2); }
.memberCol[data-index="3"]{ background:var(--col3); }

.memberHead{
  position:sticky; top:0; z-index:3; background:rgba(255,255,255,.85); backdrop-filter:saturate(120%) blur(4px);
  color:#1f2937; font-weight:800; text-align:center; padding:6px 6px; border-radius:6px; margin:6px; box-shadow:0 2px 8px rgba(0,0,0,.06);
}

/* カード（アイコンのみ、列色に合わせる） */
.card{
  position:absolute; left:4px; right:4px;
  min-height: calc(var(--px-per-min) * 10); /* 最短10分 */
  color:var(--card-ink);
  border-radius:12px; padding:6px 8px;
  font-weight:900; font-size:18px; line-height:1; text-align:center;
  box-shadow:0 8px 14px rgba(0,0,0,.15);
  touch-action:none; user-select:none;
}
.card .icon{ display:block; }
.card .resize{ position:absolute; left:0; right:0; bottom:-6px; height:12px; cursor:ns-resize; }
.card.dragging{opacity:.92; outline:2px solid rgba(255,255,255,.6)}
.card.ghost{opacity:.6}

/* 左スワイプで削除ボタン */
.card{ transition:transform .15s ease; }
.card.swipeLeft{ transform:translateX(-60px); }
.card .delBtn{
  position:absolute; top:50%; right:-54px; transform:translateY(-50%);
  background:#ef4444; color:#fff; border:none; border-radius:10px; padding:8px 10px; font-weight:800;
  box-shadow:0 6px 12px rgba(239,68,68,.35);
}

/* 特殊ライン */
.departLine,.nowLine{ position:absolute; left:0; right:0; height:2px; z-index:2; }
.departLine{ background:var(--brand) }
.nowLine{ background:var(--accent) }
.departHandle{
  position:absolute; right:6px; top:-10px; background:var(--brand); color:#fff; padding:6px 10px; border-radius:8px;
  font-weight:900; font-size:13px; box-shadow:var(--shadow); touch-action:none; user-select:none;
}

/* タスクパレット（前面にしてボタン無反応バグ回避） */
.palette{ position:relative; z-index:2; margin-top:10px; background:#111827; color:#e5e7eb; border-radius:16px; padding:12px; box-shadow:var(--shadow); }
.palette h3{margin:0 0 8px 0; font-size:14px; letter-spacing:.02em}
.tags{display:flex; flex-wrap:wrap; gap:8px; max-height:40vh; overflow:auto}
.tag{
  background:#3b82f6; color:#fff; padding:8px 10px; border-radius:999px; font-weight:700; font-size:14px;
  box-shadow:0 6px 12px rgba(59,130,246,.3); touch-action:none; user-select:none; white-space:nowrap;
}
.tag:active{transform:scale(.98)}
.addRow{display:flex; gap:8px; margin-top:10px}
.small{font-size:12px; color:#cbd5e1}

/* トースト＆アラームオーバーレイ */
.toast{
  position:fixed; left:50%; bottom:calc(12px + env(safe-area-inset-bottom)); transform:translateX(-50%);
  background:#111827; color:#fff; padding:10px 14px; border-radius:999px; box-shadow:var(--shadow); font-weight:700; z-index:60; opacity:0; pointer-events:none; transition:opacity .2s;
}
.toast.show{opacity:1}
.alarm{
  position:fixed; inset:0; background:rgba(0,0,0,.6); z-index:80; display:none; align-items:center; justify-content:center;
}
.alarm .panel{
  background:#fff; border-radius:16px; padding:18px; width:min(86vw,420px); text-align:center; box-shadow:0 14px 40px rgba(0,0,0,.2);
}
.alarm .panel .msg{ font-size:28px; font-weight:900; margin-bottom:6px; }
.alarm .panel .sub{ color:#555; margin-bottom:14px; }
.alarm .panel .ok{ background:var(--brand); color:#fff; border:none; border-radius:10px; padding:10px 14px; font-weight:800; }

/* iOSテキスト選択抑止 */
input,button{ -webkit-tap-highlight-color: transparent; }
</style>
</head>
<body>
<div class="app">
  <div class="header">
    <div class="title">
      <span class="ttl">出発時間の共有</span>
      <input class="input place" id="place" placeholder="行き先（例：イオンモール）">
      <div class="departBig">出発 <input class="input" id="depart" type="time" step="600" style="font-weight:900; width:98px"></div>
      <span class="countdown" id="countdown">--:--</span>
      <button class="btn ghost" id="soundBtn" title="初回のみ">サウンド有効化</button>
      <button class="btn" id="saveBtn">保存</button>
    </div>
    <div class="controls">
      <button class="btn ghost" id="resetBtn">全削除</button>
      <button class="btn primary" id="shareBtn">共有リンク</button>
    </div>
  </div>

  <div class="gridwrap" id="gridwrap">
    <div id="grid" class="grid">
      <!-- 左：時間軸 -->
      <div class="timeAxis" id="timeAxis"></div>

      <!-- 右：メンバー列4本（固定色・名前） -->
      <div class="memberCol" data-index="0"><div class="memberHead">のすけ</div></div>
      <div class="memberCol" data-index="1"><div class="memberHead">ママ</div></div>
      <div class="memberCol" data-index="2"><div class="memberHead">そう</div></div>
      <div class="memberCol" data-index="3"><div class="memberHead">しゅう</div></div>

      <!-- 特殊ライン -->
      <div class="departLine" id="departLine"></div>
      <div class="nowLine" id="nowLine"></div>
      <div class="departHandle" id="departHandle">出発</div>
    </div>
  </div>

  <div class="palette" id="palette">
    <h3>【タスク】（ドラッグでタイムラインへ）</h3>
    <div class="tags" id="tags"></div>
    <div class="addRow">
      <input class="input" id="newTask" placeholder="タスクを追加（例：水筒）" />
      <button class="btn" id="addTaskBtn" type="button">追加</button>
      <span class="small">※ 長押しでパレット削除／タイムラインのカードは左スワイプで削除</span>
    </div>
  </div>
</div>

<!-- トースト -->
<div class="toast" id="toast"></div>

<!-- アラーム -->
<div class="alarm" id="alarm">
  <div class="panel">
    <div class="msg" id="alarmMsg">10分前</div>
    <div class="sub">出発の準備は大丈夫？</div>
    <button class="ok" id="alarmOK">OK</button>
  </div>
</div>

<script>
(() => {
  // ====== DOM ======
  const gridwrap = document.getElementById('gridwrap');
  const grid = document.getElementById('grid');
  const timeAxis = document.getElementById('timeAxis');
  const departLine = document.getElementById('departLine');
  const departHandle = document.getElementById('departHandle');
  const nowLine = document.getElementById('nowLine');
  const placeEl = document.getElementById('place');
  const departEl = document.getElementById('depart');
  const saveBtn = document.getElementById('saveBtn');
  const resetBtn = document.getElementById('resetBtn');
  const shareBtn = document.getElementById('shareBtn');
  const tagsWrap = document.getElementById('tags');
  const addTaskBtn = document.getElementById('addTaskBtn');
  const newTaskEl = document.getElementById('newTask');
  const toastEl = document.getElementById('toast');
  const soundBtn = document.getElementById('soundBtn');
  const countdownEl = document.getElementById('countdown');
  const alarmEl = document.getElementById('alarm');
  const alarmMsgEl = document.getElementById('alarmMsg');
  const alarmOK = document.getElementById('alarmOK');

  // ====== Emoji Map ======
  const EMOJI = { "トイレ":"🚽","化粧":"💄","着替え":"👕","持ち物":"👜","食器片付け":"🍽️","ゴミ捨て":"🗑️" };
  const iconOf = (name) => EMOJI[name] || "📌";
  const withIcon = (name) => `${iconOf(name)} ${name}`;

  // ====== State ======
  const LS_KEYS = ['tripshare_v4','tripshare_v3','tripshare_v2'];
  let state = {
    place: "",
    departAt: +roundToSlot(new Date(), 10),
    slot: 10, // 10分刻み
    tasksPalette: ["着替え","トイレ","持ち物","食器片付け","ゴミ捨て","化粧"],
    events: [], // {id, memberIndex, title, start(ms), end(ms)}
  };

  // 固定パレット色（列背景/カード）
  const CARD_COLORS = ['#3b82f6','#ef476f','#06d6a0','#ffa600'];

  // ====== Audio (WebAudio) ======
  let audioCtx = null, beepOsc = null, beepGain = null, alarmTimer = null;
  function initAudio(){
    if(!audioCtx){
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    if(audioCtx.state === 'suspended') audioCtx.resume();
    showToast("サウンドを有効化しました");
  }
  soundBtn.addEventListener('click', initAudio);

  function startBeep(){
    if(!audioCtx){ return; } // 未許可
    stopBeep();
    beepOsc = audioCtx.createOscillator();
    beepGain = audioCtx.createGain();
    beepOsc.type = 'sine'; // 素直なビープ
    beepOsc.frequency.value = 880; // A5
    beepOsc.connect(beepGain); beepGain.connect(audioCtx.destination);
    beepGain.gain.setValueAtTime(0.0001, audioCtx.currentTime);
    // パルスっぽく断続（聞きやすく）
    for(let i=0;i<60;i++){
      const t = audioCtx.currentTime + i*0.5;
      beepGain.gain.setValueAtTime(0.001, t);
      beepGain.gain.exponentialRampToValueAtTime(0.08, t+0.1);
      beepGain.gain.exponentialRampToValueAtTime(0.001, t+0.5);
    }
    beepOsc.start();
  }
  function stopBeep(){
    if(beepOsc){ try{beepOsc.stop();}catch{} beepOsc.disconnect(); beepOsc=null; }
    if(beepGain){ try{beepGain.disconnect();}catch{} beepGain=null; }
    if(alarmTimer){ clearTimeout(alarmTimer); alarmTimer=null; }
  }

  // ====== Helpers ======
  function showToast(msg){ toastEl.textContent=msg; toastEl.classList.add('show'); setTimeout(()=>toastEl.classList.remove('show'),1600); }
  function pad(n){return (n<10?'0':'')+n}
  function fmtHM(d){ return pad(d.getHours())+":"+pad(d.getMinutes()) }
  function parseHM(hm, baseDate=new Date()){
    const [h,m]=hm.split(':').map(Number); const d=new Date(baseDate);
    d.setHours(h,m||0,0,0); return d;
  }
  function roundToSlot(d, mins){ const base=new Date(d); base.setSeconds(0,0); const q=Math.round(base.getMinutes()/mins)*mins; base.setMinutes(q); return base; }
  function clamp(v,min,max){ return Math.max(min, Math.min(max,v)); }
  function pxPerMin(){ return Number(getComputedStyle(document.documentElement).getPropertyValue('--px-per-min')); }
  function getWindow(){
    const dep=new Date(state.departAt);
    const start=new Date(+dep - 150*60*1000); // 2.5h
    const end  =new Date(+dep +  30*60*1000); // 0.5h
    return {start,end,durationMs:(+end - +start)};
  }

  // ====== Load/Save with migration ======
  function load(){
    for(const key of LS_KEYS){
      const s=localStorage.getItem(key);
      if(s){ try{ state=JSON.parse(s); break; }catch(e){} }
    }
  }
  function save(){ localStorage.setItem(LS_KEYS[0], JSON.stringify(state)); }

  // ====== Build Palette ======
  function rebuildTags(){
    tagsWrap.innerHTML="";
    state.tasksPalette.forEach(name=>{
      const t=document.createElement('div');
      t.className='tag';
      t.textContent = withIcon(name); // パレットはアイコン＋文字
      tagsWrap.appendChild(t);

      // 長押し削除 & D&D
      let pressTimer=null, dragging=false, startX=0, startY=0, pid=null, ghost=null;
      const clearTimer=()=>{ if(pressTimer){ clearTimeout(pressTimer); pressTimer=null; } };
      const startLongPress=(x,y)=>{
        startX=x; startY=y; clearTimer();
        pressTimer=setTimeout(()=>{
          if(!dragging && confirm(`「${name}」をパレットから削除しますか？`)){
            state.tasksPalette=state.tasksPalette.filter(x=>x!==name);
            rebuildTags(); save();
          }
        }, 600);
      };
      const moved=(x,y)=> Math.hypot(x-startX, y-startY) > 8;

      const onDown=(e)=>{ pid=e.pointerId; dragging=false; ghost=null; startLongPress(e.clientX,e.clientY); t.setPointerCapture(pid); };
      const onMove=(e)=>{ if(pid!==e.pointerId) return;
        if(moved(e.clientX,e.clientY) && !dragging){ clearTimer(); dragging=true; ghost=startGhostDrag(name); }
        if(dragging && ghost){ e.preventDefault(); ghost.move(e.clientX,e.clientY); }
      };
      const onUp=(e)=>{ if(pid!==e.pointerId) return; clearTimer();
        if(dragging && ghost){ ghost.up(e.clientX,e.clientY); }
        dragging=false; ghost=null; pid=null; t.releasePointerCapture(e.pointerId);
      };

      t.addEventListener('pointerdown', onDown);
      t.addEventListener('pointermove', onMove);
      t.addEventListener('pointerup', onUp);
    });
  }

  // Add button
  addTaskBtn.addEventListener('click', ()=>{
    const v=newTaskEl.value.trim(); if(!v) return;
    if(!state.tasksPalette.includes(v)){ state.tasksPalette.push(v); rebuildTags(); save(); }
    newTaskEl.value="";
    // 追加直後にパレットを末尾へスクロール
    tagsWrap.scrollTo({left:0, top:tagsWrap.scrollHeight, behavior:'smooth'});
    showToast("タスクを追加しました");
  });

  // ====== D&D ghost from palette ======
  function startGhostDrag(title){
    const ghost=document.createElement('div');
    ghost.className='card ghost';
    ghost.style.top='-1000px';
    ghost.style.height=(pxPerMin()*state.slot)+'px';
    ghost.style.background = 'rgba(0,0,0,.25)';
    ghost.innerHTML = `<span class="icon">${iconOf(title)}</span>`;
    grid.appendChild(ghost);

    let overColIndex=-1;

    const move=(clientX, clientY)=>{
      const rect=grid.getBoundingClientRect();
      ghost.style.left = (clientX - rect.left - 20) + 'px';
      ghost.style.top  = (clientY - rect.top  - 24) + 'px';
      overColIndex=-1;
      document.querySelectorAll('.memberCol').forEach((col,idx)=>{
        const r=col.getBoundingClientRect();
        if(clientX>r.left && clientX<r.right && clientY>r.top && clientY<r.bottom){ overColIndex=idx; }
      });

      // タイムラインのみ自動スクロール
      const gwRect = gridwrap.getBoundingClientRect();
      const margin = 60;
      if(clientY > gwRect.bottom - margin) gridwrap.scrollTop += 12;
      if(clientY < gwRect.top + margin)    gridwrap.scrollTop -= 12;
    };

    const up=(clientX, clientY)=>{
      ghost.remove();
      if(overColIndex===-1) return;
      const col = memberCol(overColIndex);
      const r=col.getBoundingClientRect();
      const y = clamp(clientY - r.top + gridwrap.scrollTop - gridwrap.offsetTop, 0, r.height + gridwrap.scrollTop);
      const slotPx = state.slot * pxPerMin();
      const ny = Math.round(y/slotPx)*slotPx;
      const start = +getWindow().start + (ny/pxPerMin())*60000;
      const end   = start + state.slot*60000;
      const id = (crypto && crypto.randomUUID) ? crypto.randomUUID() : String(Date.now()+Math.random());
      const ev = { id, memberIndex:overColIndex, title:title, start, end };
      state.events.push(ev); save(); addCard(ev);
    };

    return { move, up };
  }

  // ====== Grid build ======
  function rebuildGrid(){
    const win=getWindow();
    const durMin = (win.durationMs/60000)|0; // 180分
    grid.style.height = (durMin * pxPerMin()) + "px";

    // 時間軸
    timeAxis.innerHTML="";
    const step = state.slot; // 10分刻み
    for(let m=0; m<=durMin; m+=step){
      const y = m*pxPerMin();
      const tick=document.createElement('div');
      const abs = new Date(+win.start + m*60000);
      const isHour = abs.getMinutes()===0;
      tick.className='tick' + (isHour?' hour':'');
      tick.style.top = y + "px";
      timeAxis.appendChild(tick);
      if(isHour){
        const lab=document.createElement('div'); lab.className='label';
        lab.style.top = y + "px";
        lab.textContent = `${pad(abs.getHours())}:${pad(abs.getMinutes())}`;
        timeAxis.appendChild(lab);
      }
    }

    // ライン
    placeDepartLine(); placeNowLine();

    // 既存カード再描画
    document.querySelectorAll('.memberCol').forEach(col=> col.querySelectorAll('.card').forEach(el=>el.remove()));
    state.events.forEach(ev=> addCard(ev));
  }

  function placeDepartLine(){
    const win=getWindow();
    const y = ((+new Date(state.departAt) - +win.start)/60000) * pxPerMin();
    departLine.style.top = y + "px";
    departHandle.style.top = (y - 26) + "px";
    departHandle.textContent = "出発 " + fmtHM(new Date(state.departAt));
  }
  function placeNowLine(){
    const win=getWindow();
    const now=new Date();
    const y = clamp(((+now - +win.start)/60000) * pxPerMin(), -1000, (+win.end - +win.start)/60000 * pxPerMin());
    nowLine.style.top = y + "px";
  }
  setInterval(placeNowLine, 60000); // 1分ごと

  function memberCol(index){ return document.querySelectorAll('.memberCol')[index]; }

  // ====== Card (move / long-press resize / left-swipe delete) ======
  function addCard(ev){
    const col = memberCol(ev.memberIndex);
    const win=getWindow();
    const y0 = ((ev.start - +win.start)/60000) * pxPerMin();
    const h  = ((ev.end   - ev.start)/60000) * pxPerMin();

    const card=document.createElement('div');
    card.className='card';
    card.style.top = y0 + "px";
    card.style.height = Math.max(h, pxPerMin()*10) + "px";
    card.style.background = CARD_COLORS[ev.memberIndex] || '#3b82f6';
    card.dataset.id = ev.id;
    card.dataset.member = ev.memberIndex;
    card.innerHTML = `<span class="icon">${iconOf(ev.title)}</span><div class="resize"></div><button class="delBtn" title="削除">削除</button>`;

    // --- gestures state ---
    let pid=null, startY=null, origTop=null, resizing=false, resizeMode=false, origHeight=null;
    let startX=null, swiped=false;

    const slotPx = state.slot * pxPerMin();

    const enterResizeMode = ()=>{ resizeMode=true; card.classList.add('dragging'); if(navigator.vibrate) navigator.vibrate(10); };
    const leaveResizeMode = ()=>{ resizeMode=false; card.classList.remove('dragging'); };

    // 長押しでリサイズモード（600ms）
    let holdTimer=null;
    const startHold=(x,y)=>{ clearTimeout(holdTimer); holdTimer=setTimeout(()=>enterResizeMode(), 600); startX=x; };
    const cancelHold=()=>{ clearTimeout(holdTimer); };

    // pointer handlers
    const onDown=(e)=>{
      e.preventDefault();
      card.setPointerCapture(e.pointerId);
      pid=e.pointerId; startY=e.clientY; origTop=parseFloat(card.style.top); origHeight=parseFloat(card.style.height);
      resizing = e.target.classList.contains('resize');
      startHold(e.clientX,e.clientY);
    };
    const onMove=(e)=>{
      if(pid!==e.pointerId || startY==null) return;
      // 左スワイプ判定（水平移動が大、垂直小）
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      if(!resizeMode && Math.abs(dx) > 22 && Math.abs(dy) < 16){
        cancelHold();
        swiped = dx < -22;
        card.classList.toggle('swipeLeft', swiped);
      }
      // ドラッグ or リサイズ
      if(resizeMode || resizing){
        cancelHold();
        let nh = origHeight + dy;
        nh = Math.max(slotPx, Math.round(nh/slotPx)*slotPx);
        card.style.height = nh + "px";
      }else if(!swiped){
        // 移動
        let ny=origTop + dy;
        ny = Math.round(ny/slotPx)*slotPx;
        card.style.top = ny + "px";
        // タイムライン自動スクロール
        const gwRect = gridwrap.getBoundingClientRect();
        const margin = 60;
        if(e.clientY > gwRect.bottom - margin) gridwrap.scrollTop += 10;
        if(e.clientY < gwRect.top + margin)    gridwrap.scrollTop -= 10;
      }
    };
    const onUp=(e)=>{
      if(pid!==e.pointerId) return;
      cancelHold();
      card.releasePointerCapture(e.pointerId);
      card.classList.remove('dragging');

      // del button active?
      // stateへ反映
      const ny=parseFloat(card.style.top);
      const nh=parseFloat(card.style.height);
      const startMs = +getWindow().start + (ny/pxPerMin())*60000;
      const endMs   = startMs + (nh/pxPerMin())*60000;
      const s = state.events.find(x=>x.id===ev.id);
      if(s){ s.start=startMs; s.end=endMs; save(); }
      pid=null; startY=null; resizing=false; leaveResizeMode();
    };

    // 削除ボタン
    card.querySelector('.delBtn').addEventListener('click', (e)=>{
      e.stopPropagation();
      if(confirm('このカードを削除しますか？')){
        state.events = state.events.filter(x=>x.id!==ev.id);
        card.remove(); save();
      }else{
        card.classList.remove('swipeLeft');
      }
    });

    card.addEventListener('pointerdown', onDown, {passive:false});
    card.addEventListener('pointermove', onMove, {passive:false});
    card.addEventListener('pointerup', onUp);

    col.appendChild(card);
  }

  // ====== Depart handle drag ======
  (()=> {
    let pid=null, startY=null, startTop=null;
    const down=(e)=>{ e.preventDefault(); departHandle.setPointerCapture(e.pointerId); pid=e.pointerId; startY=e.clientY; startTop=parseFloat(departHandle.style.top)||0; };
    const move=(e)=>{
      if(pid!==e.pointerId) return;
      const dy=e.clientY-startY;
      const slotPx = state.slot * pxPerMin();
      const ny=Math.round((startTop+dy)/slotPx)*slotPx;
      departHandle.style.top = ny+"px";
      departLine.style.top = (ny+26)+"px";
    };
    const up=(e)=>{
      if(pid!==e.pointerId) return;
      departHandle.releasePointerCapture(e.pointerId);
      pid=null;
      const win=getWindow();
      const y=parseFloat(departLine.style.top);
      const newDep = +win.start + (y/pxPerMin())*60000;
      if (newDep !== state.departAt){
        if(confirm("時間変更を通知しますか？")){
          state.departAt = newDep; save();
          rebuildGrid(); placeDepartLine();
          showToast("出発時間を更新しました（通知は後でPush対応）");
          resetAlarms();
        }else{
          rebuildGrid(); // 戻す
        }
      }
    };
    departHandle.addEventListener('pointerdown', down);
    departHandle.addEventListener('pointermove', move);
    departHandle.addEventListener('pointerup', up);
  })();

  // ====== Header ======
  saveBtn.addEventListener('click', ()=>{
    state.place = placeEl.value.trim();
    const hm = departEl.value || fmtHM(new Date(state.departAt));
    state.departAt = +parseHM(hm, new Date(state.departAt));
    save(); rebuildGrid(); showToast("保存しました"); resetAlarms();
  });
  resetBtn.addEventListener('click', ()=>{
    if(confirm('全てのカードと設定を削除しますか？')){
      state.events=[]; save(); rebuildGrid();
    }
  });
  shareBtn.addEventListener('click', ()=>{
    const data = encodeURIComponent(btoa(unescape(encodeURIComponent(JSON.stringify(state)))));
    const url = location.origin+location.pathname+'?state='+data;
    navigator.clipboard.writeText(url).then(()=> showToast("共有リンクをコピーしました"));
  });

  // ====== Import via URL ======
  (function importFromQuery(){
    const p=new URLSearchParams(location.search).get('state');
    if(p){
      try{
        const obj=JSON.parse(decodeURIComponent(escape(atob(decodeURIComponent(p)))));
        state=obj; save(); history.replaceState({},"",location.pathname);
      }catch(e){}
    }
  })();

  // ====== Countdown & Alarms ======
  const ALARM_MINUTES = [30,20,10,5];
  let fired = {};
  function resetAlarms(){ fired={}; updateCountdown(); }
  function updateCountdown(){
    const now = new Date();
    const diff = state.departAt - +now;
    if(isNaN(diff)) return countdownEl.textContent='--:--';
    const s = Math.max(0, Math.floor(diff/1000));
    const mm = Math.floor(s/60), ss = s%60;
    countdownEl.textContent = `残り ${pad(mm)}:${pad(ss)}`;

    // アラーム判定（分単位で正確化）
    const mins = Math.ceil(diff/60000);
    if(ALARM_MINUTES.includes(mins) && !fired[mins]){
      fired[mins]=true;
      triggerAlarm(mins);
    }
  }
  setInterval(updateCountdown, 1000);

  function triggerAlarm(mins){
    alarmMsgEl.textContent = `${mins}分前`;
    alarmEl.style.display='flex';
    if(navigator.vibrate) navigator.vibrate([60,120,60,120,60]);

    // サウンド（30秒）
    startBeep();
    alarmTimer = setTimeout(()=>{ stopBeep(); }, 30000);
  }

  alarmOK.addEventListener('click', ()=>{
    alarmEl.style.display='none';
    stopBeep();
  });

  // ====== Init ======
  function init(){
    load();
    placeEl.value = state.place||"";
    const dep = new Date(state.departAt);
    departEl.value = pad(dep.getHours())+":"+pad(dep.getMinutes());
    rebuildTags();
    rebuildGrid();
    updateCountdown();
  }
  init();

})();
</script>
</body>
</html>
